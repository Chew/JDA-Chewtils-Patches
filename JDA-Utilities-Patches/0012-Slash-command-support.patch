From bc6830c1548f9e8853db4124cc349e8e1c0dffa8 Mon Sep 17 00:00:00 2001
From: Chew <chew@chew.pw>
Date: Sun, 23 May 2021 17:46:44 -0500
Subject: [PATCH] Slash command support


diff --git a/build.gradle b/build.gradle
index 0b5d4e2..8d89cce 100644
--- a/build.gradle
+++ b/build.gradle
@@ -37,7 +37,7 @@ allprojects {
     version = versionInfo.values().join('.')
 
     ext {
-        jdaVersion = '4.2.0_214'
+        jdaVersion = 'feature~slash-commands-SNAPSHOT'
         slf4jVersion = '1.7.25'
         okhttpVersion = '3.13.0'
         findbugsVersion = '3.0.2'
@@ -45,7 +45,7 @@ allprojects {
         junitVersion = '4.13.1' // TODO Move to junit 5?
 
         dependencies {
-            jda = { [group: 'net.dv8tion', name: 'JDA', version: jdaVersion] }
+            jda = { [group: 'com.github.dv8fromtheworld', name: 'jda', version: jdaVersion] }
             slf4j = { [group: 'org.slf4j', name: 'slf4j-api', version: slf4jVersion] }
             okhttp = { [group: 'com.squareup.okhttp3', name: 'okhttp', version: okhttpVersion] }
             findbugs = { [group: 'com.google.code.findbugs', name: 'jsr305', version: findbugsVersion] }
@@ -92,6 +92,9 @@ allprojects {
 
     repositories {
         jcenter()
+        maven { url 'https://jitpack.io' }
+        mavenCentral()
+        mavenLocal()
     }
 
     build {
diff --git a/command/src/main/java/com/jagrosh/jdautilities/command/CommandClient.java b/command/src/main/java/com/jagrosh/jdautilities/command/CommandClient.java
index f8db009..76627dd 100644
--- a/command/src/main/java/com/jagrosh/jdautilities/command/CommandClient.java
+++ b/command/src/main/java/com/jagrosh/jdautilities/command/CommandClient.java
@@ -168,6 +168,63 @@ public interface CommandClient
      */
     void addCommand(Command command, int index);
 
+    /**
+     * Adds a single {@link com.jagrosh.jdautilities.command.SlashCommand SlashCommand} to this CommandClient's
+     * registered SlashCommand.
+     *
+     * <p>For CommandClient's containing 20 commands or less, command calls by users will have the bot iterate
+     * through the entire {@link java.util.ArrayList ArrayList} to find the command called. As expected, this
+     * can get fairly hefty if a bot has a lot of Commands registered to it.
+     *
+     * <p>To prevent delay a CommandClient that has more that 20 Commands registered to it will begin to use
+     * <b>indexed calls</b>.
+     * <br>Indexed calls use a {@link java.util.HashMap HashMap} which links their
+     * {@link com.jagrosh.jdautilities.command.SlashCommand#name name} to the index that which they
+     * are located at in the ArrayList they are stored.
+     *
+     * <p>This means that all insertion and removal of SlashCommands must reorganize the index maintained by the HashMap.
+     * <br>For this particular insertion, the SlashCommand provided is inserted at the end of the index, meaning it will
+     * become the "rightmost" Command in the ArrayList.
+     *
+     * @param  command
+     *         The Command to add
+     *
+     * @throws java.lang.IllegalArgumentException
+     *         If the SlashCommand provided has a name or alias that has already been registered
+     */
+    void addSlashCommand(SlashCommand command);
+
+    /**
+     * Adds a single {@link com.jagrosh.jdautilities.command.SlashCommand SlashCommand} to this CommandClient's
+     * registered Commands at the specified index.
+     *
+     * <p>For CommandClient's containing 20 commands or less, command calls by users will have the bot iterate
+     * through the entire {@link java.util.ArrayList ArrayList} to find the command called. As expected, this
+     * can get fairly hefty if a bot has a lot of Commands registered to it.
+     *
+     * <p>To prevent delay a CommandClient that has more that 20 Commands registered to it will begin to use
+     * <b>indexed calls</b>.
+     * <br>Indexed calls use a {@link java.util.HashMap HashMap} which links their
+     * {@link com.jagrosh.jdautilities.command.Command#name name} to the index that which they
+     * are located at in the ArrayList they are stored.
+     *
+     * <p>This means that all insertion and removal of Commands must reorganize the index maintained by the HashMap.
+     * <br>For this particular insertion, the Command provided is inserted at the index specified, meaning it will
+     * become the Command located at that index in the ArrayList. This will shift the Command previously located at
+     * that index as well as any located at greater indices, right one index ({@code size()+1}).
+     *
+     * @param  command
+     *         The Command to add
+     * @param  index
+     *         The index to add the Command at (must follow the specifications {@code 0<=index<=size()})
+     *
+     * @throws java.lang.ArrayIndexOutOfBoundsException
+     *         If {@code index < 0} or {@code index > size()}
+     * @throws java.lang.IllegalArgumentException
+     *         If the Command provided has a name or alias that has already been registered to an index
+     */
+    void addSlashCommand(SlashCommand command, int index);
+
     /**
      * Removes a single {@link com.jagrosh.jdautilities.command.Command Command} from this CommandClient's
      * registered Commands at the index linked to the provided name/alias.
diff --git a/command/src/main/java/com/jagrosh/jdautilities/command/CommandClientBuilder.java b/command/src/main/java/com/jagrosh/jdautilities/command/CommandClientBuilder.java
index 6d0e434..1defeb2 100644
--- a/command/src/main/java/com/jagrosh/jdautilities/command/CommandClientBuilder.java
+++ b/command/src/main/java/com/jagrosh/jdautilities/command/CommandClientBuilder.java
@@ -54,6 +54,7 @@ public class CommandClientBuilder
     private String carbonKey;
     private String botsKey;
     private final LinkedList<Command> commands = new LinkedList<>();
+    private final LinkedList<SlashCommand> slashCommands = new LinkedList<>();
     private CommandListener listener;
     private boolean useHelp = true;
     private boolean shutdownAutomatically = true;
@@ -75,7 +76,7 @@ public class CommandClientBuilder
     public CommandClient build()
     {
         CommandClient client = new CommandClientImpl(ownerId, coOwnerIds, prefix, altprefix, prefixes, prefixFunction, commandPreProcessFunction, activity, status, serverInvite,
-                                                     success, warning, error, carbonKey, botsKey, new ArrayList<>(commands), useHelp,
+                                                     success, warning, error, carbonKey, botsKey, new ArrayList<>(commands), new ArrayList<>(slashCommands), useHelp,
                                                      shutdownAutomatically, helpConsumer, helpWord, executor, linkedCacheSize, compiler, manager);
         if(listener!=null)
             client.setListener(listener);
@@ -346,6 +347,38 @@ public class CommandClientBuilder
         return this;
     }
 
+    /**
+     * Adds a {@link com.jagrosh.jdautilities.command.SlashCommand SlashCommand} and registers it to the
+     * {@link com.jagrosh.jdautilities.command.impl.CommandClientImpl CommandClientImpl} for this session.
+     *
+     * @param  command
+     *         The SlashCommand to add
+     *
+     * @return This builder
+     */
+    public CommandClientBuilder addSlashCommand(SlashCommand command)
+    {
+        slashCommands.add(command);
+        return this;
+    }
+
+    /**
+     * Adds and registers multiple {@link com.jagrosh.jdautilities.command.SlashCommand SlashCommand}s to the
+     * {@link com.jagrosh.jdautilities.command.impl.CommandClientImpl CommandClientImpl} for this session.
+     * <br>This is the same as calling {@link com.jagrosh.jdautilities.command.CommandClientBuilder#addSlashCommand(SlashCommand)} multiple times.
+     *
+     * @param  commands
+     *         The Commands to add
+     *
+     * @return This builder
+     */
+    public CommandClientBuilder addSlashCommands(SlashCommand... commands)
+    {
+        for(SlashCommand command: commands)
+            this.addSlashCommand(command);
+        return this;
+    }
+
     /**
      * Adds an annotated command module to the
      * {@link com.jagrosh.jdautilities.command.impl.CommandClientImpl CommandClientImpl} for this session.
diff --git a/command/src/main/java/com/jagrosh/jdautilities/command/SlashCommand.java b/command/src/main/java/com/jagrosh/jdautilities/command/SlashCommand.java
new file mode 100644
index 0000000..0abf860
--- /dev/null
+++ b/command/src/main/java/com/jagrosh/jdautilities/command/SlashCommand.java
@@ -0,0 +1,900 @@
+/*
+ * Copyright 2016-2018 John Grosh (jagrosh) & Kaidan Gustave (TheMonitorLizard)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.jagrosh.jdautilities.command;
+
+import net.dv8tion.jda.api.Permission;
+import net.dv8tion.jda.api.entities.ChannelType;
+import net.dv8tion.jda.api.entities.GuildVoiceState;
+import net.dv8tion.jda.api.entities.Member;
+import net.dv8tion.jda.api.entities.TextChannel;
+import net.dv8tion.jda.api.entities.VoiceChannel;
+import net.dv8tion.jda.api.events.interaction.SlashCommandEvent;
+import net.dv8tion.jda.api.interactions.commands.build.OptionData;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.function.Predicate;
+
+/**
+ * <h1><b>Slash Commands In JDA-Chewtils</b></h1>
+ * 
+ * <p>This intends to mimic the {@link Command command} with minimal breaking changes,
+ * to make migration easy and smooth.</p>
+ * <p>Breaking changes are documented here: https://github.</p>
+ * {@link SlashCommand#execute(SlashCommandEvent) #execute(CommandEvent)} body:
+ * 
+ * <pre><code> public class ExampleCmd extends Command {
+ *      
+ *      public ExampleCmd() {
+ *          this.name = "example";
+ *          this.help = "gives an example of commands do";
+ *      }
+ *      
+ *      {@literal @Override}
+ *      protected void execute(SlashCommandEvent event) {
+ *          event.reply("Hey look! This would be the bot's reply if this was a command!").queue();
+ *      }
+ *      
+ * }</code></pre>
+ * 
+ * Execution is with the provision of the SlashCommandEvent is performed in two steps:
+ * <ul>
+ *     <li>{@link SlashCommand#run(SlashCommandEvent, CommandClient) run} - The command runs
+ *     through a series of conditionals, automatically terminating the command instance if one is not met, 
+ *     and possibly providing an error response.</li>
+ *     
+ *     <li>{@link SlashCommand#execute(SlashCommandEvent) execute} - The command,
+ *     now being cleared to run, executes and performs whatever lies in the abstract body method.</li>
+ * </ul>
+ * 
+ * @author John Grosh (jagrosh)
+ */
+public abstract class SlashCommand
+{
+    /**
+     * The name of the command. This is what appears in the clients when they type "/"
+     */
+    protected String name = "null";
+
+    /**
+     * A small help String that summarizes the function of the command, used in the Discord description.
+     */
+    protected String help = "no help available";
+
+    /**
+     * The {@link com.jagrosh.jdautilities.command.SlashCommand.Category Category} of the command.
+     * <br>This can perform any other checks not completed by the default conditional fields.
+     */
+    protected Category category = null;
+
+    /**
+     * {@code true} if the command may only be used in a specified {@link net.dv8tion.jda.api.entities.Guild Guild},
+     * {@code false} if it may be used globally.
+     * <br>Default {@code false}.
+     */
+    protected boolean guildOnly = false;
+
+    /**
+     * The ID of the server you want guildOnly tied to.
+     * This means the slash command will only work and show up in the specified Guild.
+     * If this is null, guildOnly will still be processed, however an ephemeral message will be sent telling them to move.
+     */
+    protected String guildId = null;
+
+    /**
+     * A String name of a role required to use this command.
+     */
+    protected String requiredRole = null;
+
+    /**
+     * {@code true} if the command may only be used by a User with an ID matching the
+     * Owners or any of the CoOwners.
+     * <br>Default {@code false}.
+     */
+    protected boolean ownerCommand = false;
+
+    /**
+     * An {@code int} number of seconds users must wait before using this command again.
+     */
+    protected int cooldown = 0;
+
+    /**
+     * Any {@link net.dv8tion.jda.api.Permission Permission}s a Member must have to use this command.
+     * <br>These are only checked in a {@link net.dv8tion.jda.api.entities.Guild Guild} environment.
+     */
+    protected Permission[] userPermissions = new Permission[0];
+
+    /**
+     * Any {@link net.dv8tion.jda.api.Permission Permission}s the bot must have to use a command.
+     * <br>These are only checked in a {@link net.dv8tion.jda.api.entities.Guild Guild} environment.
+     */
+    protected Permission[] botPermissions = new Permission[0];
+
+    /**
+     * The child commands of the command. These are used in the format {@code [prefix]<parent name>
+     * <child name>}.
+     */
+    protected SlashCommand[] children = new SlashCommand[0];
+
+    /**
+     * {@code true} if this command checks a channel topic for topic-tags.
+     * <br>This means that putting {@code {-commandname}}, {@code {-command category}}, {@code {-all}} in a channel topic
+     * will cause this command to terminate.
+     * <br>Default {@code true}.
+     */
+    protected boolean usesTopicTags = true;
+
+    /**
+     * The {@link com.jagrosh.jdautilities.command.SlashCommand.CooldownScope CooldownScope}
+     * of the command. This defines how far of a scope cooldowns have.
+     * <br>Default {@link com.jagrosh.jdautilities.command.SlashCommand.CooldownScope#USER CooldownScope.USER}.
+     */
+    protected CooldownScope cooldownScope = CooldownScope.USER;
+
+    /**
+     * The permission message used when the bot does not have the requires permission.
+     * Requires 3 "%s", first is user mention, second is the permission needed, third is type, e.g. Guild.
+     */
+    protected String botMissingPermMessage = "%s I need the %s permission in this %s!";
+
+    /**
+     * The permission message used when the user does not have the requires permission.
+     * Requires 3 "%s", first is user mention, second is the permission needed, third is type, e.g. Guild.
+     */
+    protected String userMissingPermMessage = "%s You must have the %s permission in this %s to use that!";
+
+    /**
+     * An array list of OptionData.
+     *
+     * This is to specify different options for arguments and the stuff.
+     *
+     * For example, to add an argument for "input", you can do this:<br>
+     * <pre><code> OptionData data = new OptionData(OptionType.STRING, "input", "The input for the command").setRequired(true);
+     *     List OptionData dataList = new ArrayList();
+     *     dataList.add(data);
+     *     this.options = dataList;</code></pre>
+     */
+    protected List<OptionData> options = new ArrayList<>();
+
+    /**
+     * The command client to be retrieved if needed.
+     */
+    protected CommandClient client;
+    
+    /**
+     * The main body method of a {@link SlashCommand Command}.
+     * <br>This is the "response" for a successful 
+     * {@link SlashCommand#run(SlashCommandEvent, CommandClient) #run(CommandEvent)}.
+     * 
+     * @param  event
+     *         The {@link SlashCommandEvent SlashCommandEvent} that
+     *         triggered this Command
+     */
+    protected abstract void execute(SlashCommandEvent event);
+    
+    /**
+     * Runs checks for the {@link SlashCommand SlashCommand} with the
+     * given {@link SlashCommandEvent SlashCommandEvent} that called it.
+     * <br>Will terminate, and possibly respond with a failure message, if any checks fail.
+     * 
+     * @param  event
+     *         The SlashCommandEvent that triggered this Command
+     * @param  client
+     *         The CommandClient for checks and stuff
+     */
+    public final void run(SlashCommandEvent event, CommandClient client)
+    {
+        // set the client
+        this.client = client;
+
+        // owner check
+        if(ownerCommand && !(isOwner(event, client)))
+        {
+            terminate(event,null, client);
+            return;
+        }
+
+        // category check
+        if(category!=null && !category.test(event))
+        {
+            terminate(event, category.getFailureResponse(), client);
+            return;
+        }
+
+        // is allowed check
+        if((event.getChannelType() == ChannelType.TEXT) && !isAllowed(event.getTextChannel()))
+        {
+            terminate(event, "That command cannot be used in this channel!", client);
+            return;
+        }
+        
+        // required role check
+        if(requiredRole!=null)
+            if(!(event.getChannelType() == ChannelType.TEXT) || event.getMember().getRoles().stream().noneMatch(r -> r.getName().equalsIgnoreCase(requiredRole)))
+            {
+                terminate(event, client.getError()+" You must have a role called `"+requiredRole+"` to use that!", client);
+                return;
+            }
+        
+        // availability check
+        if(event.getChannelType()==ChannelType.TEXT)
+        {
+            //user perms
+            for(Permission p: userPermissions)
+            {
+                if(p.isChannel())
+                {
+                    if(!event.getMember().hasPermission(event.getTextChannel(), p))
+                    {
+                        terminate(event, String.format(userMissingPermMessage, client.getError(), p.getName(), "channel"), client);
+                        return;
+                    }
+                }
+                else
+                {
+                    if(!event.getMember().hasPermission(p))
+                    {
+                        terminate(event, String.format(userMissingPermMessage, client.getError(), p.getName(), "server"), client);
+                        return;
+                    }
+                }
+            }
+
+            // bot perms
+            for(Permission p: botPermissions)
+            {
+                Member selfMember = event.getGuild() == null ? null : event.getGuild().getSelfMember();
+                if(p.isChannel())
+                {
+                    if(p.name().startsWith("VOICE"))
+                    {
+                        GuildVoiceState gvc = event.getMember().getVoiceState();
+                        VoiceChannel vc = gvc == null ? null : gvc.getChannel();
+                        if(vc==null)
+                        {
+                            terminate(event, client.getError()+" You must be in a voice channel to use that!", client);
+                            return;
+                        }
+                        else if(!selfMember.hasPermission(vc, p))
+                        {
+                            terminate(event, String.format(botMissingPermMessage, client.getError(), p.getName(), "voice channel"), client);
+                            return;
+                        }
+                    }
+                    else
+                    {
+                        if(!selfMember.hasPermission(event.getTextChannel(), p))
+                        {
+                            terminate(event, String.format(botMissingPermMessage, client.getError(), p.getName(), "channel"), client);
+                            return;
+                        }
+                    }
+                }
+                else
+                {
+                    if(!selfMember.hasPermission(p))
+                    {
+                        terminate(event, String.format(botMissingPermMessage, client.getError(), p.getName(), "server"), client);
+                        return;
+                    }
+                }
+            }
+        }
+        else if(guildOnly)
+        {
+            terminate(event, client.getError()+" This command cannot be used in direct messages", client);
+            return;
+        }
+        
+        // cooldown check, ignoring owner
+        if(cooldown>0 && !(isOwner(event, client)))
+        {
+            String key = getCooldownKey(event);
+            int remaining = client.getRemainingCooldown(key);
+            if(remaining>0)
+            {
+                terminate(event, getCooldownError(event, remaining, client), client);
+                return;
+            }
+            else client.applyCooldown(key, cooldown);
+        }
+        
+        // run
+        try {
+            execute(event);
+        } catch(Throwable t) {
+            if(client.getListener() != null)
+            {
+                //client.getListener().onCommandException(event, this, t);
+                return;
+            }
+            // otherwise we rethrow
+            throw t;
+        }
+
+        // TODO: this
+        //if(client.getListener() != null)
+            //client.getListener().onCompletedCommand(event, this);
+    }
+
+    /**
+     * Tests whether or not the {@link net.dv8tion.jda.api.entities.User User} who triggered this
+     * event is an owner of the bot.
+     *
+     * @param event the event that triggered the command
+     * @param client the command client for checking stuff
+     * @return {@code true} if the User is the Owner, else {@code false}
+     */
+    public boolean isOwner(SlashCommandEvent event, CommandClient client)
+    {
+        if(event.getUser().getId().equals(client.getOwnerId()))
+            return true;
+        if(client.getCoOwnerIds()==null)
+            return false;
+        for(String id : client.getCoOwnerIds())
+            if(id.equals(event.getUser().getId()))
+                return true;
+        return false;
+    }
+    
+    /**
+     * Checks if the given input represents this Command
+     * 
+     * @param  input
+     *         The input to check
+     * 
+     * @return {@code true} if the input is the name or an alias of the Command
+     */
+    public boolean isCommandFor(String input)
+    {
+        return name.equalsIgnoreCase(input);
+    }
+
+    /**
+     * Checks whether a command is allowed in a {@link TextChannel TextChannel}
+     * by searching the channel topic for topic tags relating to the command.
+     *
+     * <p>{-{@link SlashCommand#name name}},
+     * {-{@link SlashCommand.Category category name}}, or {-{@code all}}
+     * are valid examples of ways that this method would return {@code false} if placed in a channel topic.
+     *
+     * <p><b>NOTE:</b>Topic tags are <b>case sensitive</b> and proper usage must be in lower case!
+     * <br>Also note that setting {@link SlashCommand#usesTopicTags usesTopicTags}
+     * to {@code false} will cause this method to always return {@code true}, as the feature would not be applicable
+     * in the first place.
+     *
+     * @param  channel
+     *         The TextChannel to test.
+     *
+     * @return {@code true} if the channel topic doesn't specify any topic-tags that would cause this command
+     *         to be cancelled, or if {@code usesTopicTags} has been set to {@code false}.
+     */
+    public boolean isAllowed(TextChannel channel)
+    {
+        if(!usesTopicTags)
+            return true;
+        if(channel==null)
+            return true;
+        String topic = channel.getTopic();
+        if(topic==null || topic.isEmpty())
+            return true;
+        topic = topic.toLowerCase();
+        String lowerName = name.toLowerCase();
+        if(topic.contains("{"+lowerName+"}"))
+            return true;
+        if(topic.contains("{-"+lowerName+"}"))
+            return false;
+        String lowerCat = category==null ? null : category.getName().toLowerCase();
+        if(lowerCat!=null)
+        {
+            if(topic.contains("{"+lowerCat+"}"))
+                return true;
+            if(topic.contains("{-"+lowerCat+"}"))
+                return false;
+        }
+        return !topic.contains("{-all}");
+    }
+
+    /**
+     * Gets the {@link SlashCommand#name Command.name} for the Command.
+     *
+     * @return The name for the Command
+     */
+    public String getName()
+    {
+        return name;
+    }
+
+    /**
+     * Gets the {@link SlashCommand#help Command.help} for the Command.
+     *
+     * @return The help for the Command
+     */
+    public String getHelp()
+    {
+        return help;
+    }
+
+    /**
+     * Gets the CommandClient.
+     *
+     * @return the CommandClient.
+     */
+    public CommandClient getClient()
+    {
+        return client;
+    }
+
+    /**
+     * Gets the {@link SlashCommand#category Command.category} for the Command.
+     *
+     * @return The category for the Command
+     */
+    public Category getCategory()
+    {
+        return category;
+    }
+
+    /**
+     * Checks if this Command can only be used in a {@link net.dv8tion.jda.api.entities.Guild Guild}.
+     *
+     * @return {@code true} if this Command can only be used in a Guild, else {@code false} if it can
+     *         be used outside of one
+     */
+    public boolean isGuildOnly()
+    {
+        return guildOnly;
+    }
+
+    /**
+     * Gets the associated Guild ID for Guild Only command.
+     *
+     * @return the ID for the specific Guild
+     */
+    public String getGuildId()
+    {
+        return guildId;
+    }
+
+    /**
+     * Gets the options associated with this command.
+     *
+     * @return the OptionData array for options
+     */
+    public List<OptionData> getOptions()
+    {
+        return options;
+    }
+
+    /**
+     * Gets the {@link SlashCommand#requiredRole Command.requiredRole} for the Command.
+     *
+     * @return The requiredRole for the Command
+     */
+    public String getRequiredRole()
+    {
+        return requiredRole;
+    }
+
+    /**
+     * Gets the {@link SlashCommand#cooldown Command.cooldown} for the Command.
+     *
+     * @return The cooldown for the Command
+     */
+    public int getCooldown()
+    {
+        return cooldown;
+    }
+
+    /**
+     * Gets the {@link SlashCommand#userPermissions Command.userPermissions} for the Command.
+     *
+     * @return The userPermissions for the Command
+     */
+    public Permission[] getUserPermissions()
+    {
+        return userPermissions;
+    }
+
+    /**
+     * Gets the {@link SlashCommand#botPermissions Command.botPermissions} for the Command.
+     *
+     * @return The botPermissions for the Command
+     */
+    public Permission[] getBotPermissions()
+    {
+        return botPermissions;
+    }
+
+    /**
+     * Gets the {@link SlashCommand#children Command.children} for the Command.
+     *
+     * @return The children for the Command
+     */
+    public SlashCommand[] getChildren()
+    {
+        return children;
+    }
+
+    /**
+     * Checks whether or not this command is an owner only Command.
+     * 
+     * @return {@code true} if the command is an owner command, otherwise {@code false} if it is not
+     */
+    public boolean isOwnerCommand()
+    {
+        return ownerCommand;
+    }
+
+    private void terminate(SlashCommandEvent event, String message, CommandClient client)
+    {
+        if(message!=null)
+            event.reply(message).setEphemeral(true).queue();
+        /* To-Do I guess
+        if(client.getListener()!=null)
+            client.getListener().onTerminatedCommand(event, this);
+         */
+    }
+
+    /**
+     * Gets the proper cooldown key for this Command under the provided
+     * {@link CommandEvent CommandEvent}.
+     *
+     * @param  event
+     *         The CommandEvent to generate the cooldown for.
+     *
+     * @return A String key to use when applying a cooldown.
+     */
+    public String getCooldownKey(SlashCommandEvent event)
+    {
+        switch (cooldownScope)
+        {
+            case USER:         return cooldownScope.genKey(name,event.getUser().getIdLong());
+            case USER_GUILD:   return event.getGuild()!=null ? cooldownScope.genKey(name,event.getUser().getIdLong(),event.getGuild().getIdLong()) :
+                    CooldownScope.USER_CHANNEL.genKey(name,event.getUser().getIdLong(), event.getChannel().getIdLong());
+            case USER_CHANNEL: return cooldownScope.genKey(name,event.getUser().getIdLong(),event.getChannel().getIdLong());
+            case GUILD:        return event.getGuild()!=null ? cooldownScope.genKey(name,event.getGuild().getIdLong()) :
+                    CooldownScope.CHANNEL.genKey(name,event.getChannel().getIdLong());
+            case CHANNEL:      return cooldownScope.genKey(name,event.getChannel().getIdLong());
+            case SHARD:
+                event.getJDA().getShardInfo();
+                return cooldownScope.genKey(name, event.getJDA().getShardInfo().getShardId());
+            case USER_SHARD:
+                event.getJDA().getShardInfo();
+                return cooldownScope.genKey(name,event.getUser().getIdLong(),event.getJDA().getShardInfo().getShardId());
+            case GLOBAL:       return cooldownScope.genKey(name, 0);
+            default:           return "";
+        }
+    }
+
+    /**
+     * Gets an error message for this Command under the provided
+     * {@link CommandEvent CommanEvent}.
+     *
+     * @param  event
+     *         The CommandEvent to generate the error message for.
+     * @param  remaining
+     *         The remaining number of seconds a command is on cooldown for.
+     * @param client
+     *         The CommandClient for checking stuff
+     *
+     * @return A String error message for this command if {@code remaining > 0},
+     *         else {@code null}.
+     */
+    public String getCooldownError(SlashCommandEvent event, int remaining, CommandClient client)
+    {
+        if(remaining<=0)
+            return null;
+        String front = client.getWarning()+" That command is on cooldown for "+remaining+" more seconds";
+        if(cooldownScope.equals(CooldownScope.USER))
+            return front+"!";
+        else if(cooldownScope.equals(CooldownScope.USER_GUILD) && event.getGuild()==null)
+            return front+" "+ CooldownScope.USER_CHANNEL.errorSpecification+"!";
+        else if(cooldownScope.equals(CooldownScope.GUILD) && event.getGuild()==null)
+            return front+" "+ CooldownScope.CHANNEL.errorSpecification+"!";
+        else
+            return front+" "+cooldownScope.errorSpecification+"!";
+    }
+
+    /**
+     * To be used in {@link SlashCommand Command}s as a means of
+     * organizing commands into "Categories" as well as terminate command usage when the calling 
+     * {@link CommandEvent CommandEvent} doesn't meet
+     * certain requirements.
+     * 
+     * @author John Grosh (jagrosh)
+     */
+    public static class Category
+    {
+        private final String name;
+        private final String failResponse;
+        private final Predicate<SlashCommandEvent> predicate;
+        
+        /**
+         * A Command Category containing a name.
+         * 
+         * @param  name
+         *         The name of the Category
+         */
+        public Category(String name)
+        {
+            this.name = name;
+            this.failResponse = null;
+            this.predicate = null;
+        }
+        
+        /**
+         * A Command Category containing a name and a {@link Predicate}.
+         * 
+         * <p>The command will be terminated if
+         * {@link SlashCommand.Category#test(SlashCommandEvent)}
+         * returns {@code false}.
+         * 
+         * @param  name 
+         *         The name of the Category
+         * @param  predicate
+         *         The Category predicate to test
+         */
+        public Category(String name, Predicate<SlashCommandEvent> predicate)
+        {
+            this.name = name;
+            this.failResponse = null;
+            this.predicate = predicate;
+        }
+        
+        /**
+         * A Command Category containing a name, a {@link Predicate},
+         * and a failure response.
+         * 
+         * <p>The command will be terminated if
+         * {@link SlashCommand.Category#test(SlashCommandEvent)}
+         * returns {@code false}, and the failure response will be sent.
+         * 
+         * @param  name 
+         *         The name of the Category
+         * @param  failResponse
+         *         The response if the test fails
+         * @param  predicate
+         *         The Category predicate to test
+         */
+        public Category(String name, String failResponse, Predicate<SlashCommandEvent> predicate)
+        {
+            this.name = name;
+            this.failResponse = failResponse;
+            this.predicate = predicate;
+        }
+        
+        /**
+         * Gets the name of the Category.
+         * 
+         * @return The name of the Category
+         */
+        public String getName()
+        {
+            return name;
+        }
+        
+        /**
+         * Gets the failure response of the Category.
+         * 
+         * @return The failure response of the Category
+         */
+        public String getFailureResponse()
+        {
+            return failResponse;
+        }
+        
+        /**
+         * Runs a test of the provided {@link Predicate}.
+         * 
+         * @param  event
+         *         The {@link CommandEvent CommandEvent}
+         *         that was called when this method is invoked
+         *         
+         * @return {@code true} if the Predicate was not set, was set as null, or was 
+         *         tested and returned true, otherwise returns {@code false}
+         */
+        public boolean test(SlashCommandEvent event)
+        {
+            return predicate==null || predicate.test(event);
+        }
+
+        @Override
+        public boolean equals(Object obj)
+        {
+            if(!(obj instanceof Category))
+                return false;
+            Category other = (Category)obj;
+            return Objects.equals(name, other.name) && Objects.equals(predicate, other.predicate) && Objects.equals(failResponse, other.failResponse);
+        }
+
+        @Override
+        public int hashCode()
+        {
+            int hash = 7;
+            hash = 17 * hash + Objects.hashCode(this.name);
+            hash = 17 * hash + Objects.hashCode(this.failResponse);
+            hash = 17 * hash + Objects.hashCode(this.predicate);
+            return hash;
+        }
+    }
+
+    /**
+     * A series of {@link Enum Enum}s used for defining the scope size for a
+     * {@link SlashCommand Command}'s cooldown.
+     *
+     * <p>The purpose for these values is to allow easy, refined, and generally convenient keys
+     * for cooldown scopes, allowing a command to remain on cooldown for more than just the user
+     * calling it, with no unnecessary abstraction or developer input.
+     *
+     * Cooldown keys are generated via {@link SlashCommand#getCooldownKey(SlashCommandEvent)
+     * Command#getCooldownKey(CommandEvent)} using 1-2 Snowflake ID's corresponding to the name
+     * (IE: {@code USER_CHANNEL} uses the ID's of the User and the Channel from the CommandEvent).
+     *
+     * <p>However, the issue with generalizing and generating like this is that the command may
+     * be called in a non-guild environment, causing errors internally.
+     * <br>To prevent this, all of the values that contain "{@code GUILD}" in their name default
+     * to their "{@code CHANNEL}" counterparts when commands using them are called outside of a
+     * {@link net.dv8tion.jda.api.entities.Guild Guild} environment.
+     * <ul>
+     *     <li>{@link SlashCommand.CooldownScope#GUILD GUILD} defaults to
+     *     {@link SlashCommand.CooldownScope#CHANNEL CHANNEL}.</li>
+     *     <li>{@link SlashCommand.CooldownScope#USER_GUILD USER_GUILD} defaults to
+     *     {@link SlashCommand.CooldownScope#USER_CHANNEL USER_CHANNEL}.</li>
+     * </ul>
+     *
+     * These are effective across a single instance of JDA, and not multiple
+     * ones, save when multiple shards run on a single JVM and under a
+     * {@link net.dv8tion.jda.api.sharding.ShardManager ShardManager}.
+     * <br>There is no shard magic, and no guarantees for a 100% "global"
+     * cooldown, unless all shards of the bot run under the same ShardManager,
+     * and/or via some external system unrelated to JDA-Utilities.
+     *
+     * @since  1.3
+     * @author Kaidan Gustave
+     *
+     * @see    SlashCommand#cooldownScope Command.cooldownScope
+     */
+    public enum CooldownScope
+    {
+        /**
+         * Applies the cooldown to the calling {@link net.dv8tion.jda.api.entities.User User} across all
+         * locations on this instance (IE: TextChannels, PrivateChannels, etc).
+         *
+         * <p>The key for this is generated in the format
+         * <ul>
+         *     {@code <command-name>|U:<userID>}
+         * </ul>
+         */
+        USER("U:%d",""),
+
+        /**
+         * Applies the cooldown to the {@link net.dv8tion.jda.api.entities.MessageChannel MessageChannel} the
+         * command is called in.
+         *
+         * <p>The key for this is generated in the format
+         * <ul>
+         *     {@code <command-name>|C:<channelID>}
+         * </ul>
+         */
+        CHANNEL("C:%d","in this channel"),
+
+        /**
+         * Applies the cooldown to the calling {@link net.dv8tion.jda.api.entities.User User} local to the
+         * {@link net.dv8tion.jda.api.entities.MessageChannel MessageChannel} the command is called in.
+         *
+         * <p>The key for this is generated in the format
+         * <ul>
+         *     {@code <command-name>|U:<userID>|C:<channelID>}
+         * </ul>
+         */
+        USER_CHANNEL("U:%d|C:%d", "in this channel"),
+
+        /**
+         * Applies the cooldown to the {@link net.dv8tion.jda.api.entities.Guild Guild} the command is called in.
+         *
+         * <p>The key for this is generated in the format
+         * <ul>
+         *     {@code <command-name>|G:<guildID>}
+         * </ul>
+         *
+         * <p><b>NOTE:</b> This will automatically default back to {@link SlashCommand.CooldownScope#CHANNEL CooldownScope.CHANNEL}
+         * when called in a private channel.  This is done in order to prevent internal
+         * {@link NullPointerException NullPointerException}s from being thrown while generating cooldown keys!
+         */
+        GUILD("G:%d", "in this server"),
+
+        /**
+         * Applies the cooldown to the calling {@link net.dv8tion.jda.api.entities.User User} local to the
+         * {@link net.dv8tion.jda.api.entities.Guild Guild} the command is called in.
+         *
+         * <p>The key for this is generated in the format
+         * <ul>
+         *     {@code <command-name>|U:<userID>|G:<guildID>}
+         * </ul>
+         *
+         * <p><b>NOTE:</b> This will automatically default back to {@link SlashCommand.CooldownScope#CHANNEL CooldownScope.CHANNEL}
+         * when called in a private channel. This is done in order to prevent internal
+         * {@link NullPointerException NullPointerException}s from being thrown while generating cooldown keys!
+         */
+        USER_GUILD("U:%d|G:%d", "in this server"),
+
+        /**
+         * Applies the cooldown to the calling Shard the command is called on.
+         *
+         * <p>The key for this is generated in the format
+         * <ul>
+         *     {@code <command-name>|S:<shardID>}
+         * </ul>
+         *
+         * <p><b>NOTE:</b> This will automatically default back to {@link SlashCommand.CooldownScope#GLOBAL CooldownScope.GLOBAL}
+         * when {@link net.dv8tion.jda.api.JDA#getShardInfo() JDA#getShardInfo()} returns {@code null}.
+         * This is done in order to prevent internal {@link NullPointerException NullPointerException}s
+         * from being thrown while generating cooldown keys!
+         */
+        SHARD("S:%d", "on this shard"),
+
+        /**
+         * Applies the cooldown to the calling {@link net.dv8tion.jda.api.entities.User User} on the Shard
+         * the command is called on.
+         *
+         * <p>The key for this is generated in the format
+         * <ul>
+         *     {@code <command-name>|U:<userID>|S:<shardID>}
+         * </ul>
+         *
+         * <p><b>NOTE:</b> This will automatically default back to {@link SlashCommand.CooldownScope#USER CooldownScope.USER}
+         * when {@link net.dv8tion.jda.api.JDA#getShardInfo() JDA#getShardInfo()} returns {@code null}.
+         * This is done in order to prevent internal {@link NullPointerException NullPointerException}s
+         * from being thrown while generating cooldown keys!
+         */
+        USER_SHARD("U:%d|S:%d", "on this shard"),
+
+        /**
+         * Applies this cooldown globally.
+         *
+         * <p>As this implies: the command will be unusable on the instance of JDA in all types of
+         * {@link net.dv8tion.jda.api.entities.MessageChannel MessageChannel}s until the cooldown has ended.
+         *
+         * <p>The key for this is {@code <command-name>|globally}
+         */
+        GLOBAL("Global", "globally");
+
+        private final String format;
+        final String errorSpecification;
+
+        CooldownScope(String format, String errorSpecification)
+        {
+            this.format = format;
+            this.errorSpecification = errorSpecification;
+        }
+
+        String genKey(String name, long id)
+        {
+            return genKey(name, id, -1);
+        }
+
+        String genKey(String name, long idOne, long idTwo)
+        {
+            if(this.equals(GLOBAL))
+                return name+"|"+format;
+            else if(idTwo==-1)
+                return name+"|"+String.format(format,idOne);
+            else return name+"|"+String.format(format,idOne,idTwo);
+        }
+    }
+}
diff --git a/command/src/main/java/com/jagrosh/jdautilities/command/impl/CommandClientImpl.java b/command/src/main/java/com/jagrosh/jdautilities/command/impl/CommandClientImpl.java
index 5a5e7d2..3976bb8 100644
--- a/command/src/main/java/com/jagrosh/jdautilities/command/impl/CommandClientImpl.java
+++ b/command/src/main/java/com/jagrosh/jdautilities/command/impl/CommandClientImpl.java
@@ -28,9 +28,12 @@ import net.dv8tion.jda.api.events.ReadyEvent;
 import net.dv8tion.jda.api.events.ShutdownEvent;
 import net.dv8tion.jda.api.events.guild.GuildJoinEvent;
 import net.dv8tion.jda.api.events.guild.GuildLeaveEvent;
+import net.dv8tion.jda.api.events.interaction.SlashCommandEvent;
 import net.dv8tion.jda.api.events.message.MessageReceivedEvent;
 import net.dv8tion.jda.api.events.message.guild.GuildMessageDeleteEvent;
 import net.dv8tion.jda.api.hooks.EventListener;
+import net.dv8tion.jda.api.interactions.commands.build.CommandData;
+import net.dv8tion.jda.api.interactions.commands.build.OptionData;
 import net.dv8tion.jda.internal.utils.Checks;
 import okhttp3.*;
 import org.json.JSONObject;
@@ -78,7 +81,10 @@ public class CommandClientImpl implements CommandClient, EventListener
     private final Function<MessageReceivedEvent, Boolean> commandPreProcessFunction;
     private final String serverInvite;
     private final HashMap<String, Integer> commandIndex;
+    private final HashMap<String, Integer> slashCommandIndex;
     private final ArrayList<Command> commands;
+    private final ArrayList<SlashCommand> slashCommands;
+    private final ArrayList<String> slashCommandIds;
     private final String success;
     private final String warning;
     private final String error;
@@ -99,7 +105,7 @@ public class CommandClientImpl implements CommandClient, EventListener
     private int totalGuilds;
 
     public CommandClientImpl(String ownerId, String[] coOwnerIds, String prefix, String altprefix, String[] prefixes, Function<MessageReceivedEvent, String> prefixFunction, Function<MessageReceivedEvent, Boolean> commandPreProcessFunction, Activity activity, OnlineStatus status, String serverInvite,
-                             String success, String warning, String error, String carbonKey, String botsKey, ArrayList<Command> commands,
+                             String success, String warning, String error, String carbonKey, String botsKey, ArrayList<Command> commands, ArrayList<SlashCommand> slashCommands,
                              boolean useHelp, boolean shutdownAutomatically, Consumer<CommandEvent> helpConsumer, String helpWord, ScheduledExecutorService executor,
                              int linkedCacheSize, AnnotatedModuleCompiler compiler, GuildSettingsManager manager)
     {
@@ -136,7 +142,10 @@ public class CommandClientImpl implements CommandClient, EventListener
         this.carbonKey = carbonKey;
         this.botsKey = botsKey;
         this.commandIndex = new HashMap<>();
+        this.slashCommandIndex = new HashMap<>();
         this.commands = new ArrayList<>();
+        this.slashCommands = new ArrayList<>();
+        this.slashCommandIds = new ArrayList<>();
         this.cooldowns = new HashMap<>();
         this.uses = new HashMap<>();
         this.linkMap = linkedCacheSize>0 ? new FixedSizeCache<>(linkedCacheSize) : null;
@@ -182,6 +191,12 @@ public class CommandClientImpl implements CommandClient, EventListener
         {
             addCommand(command);
         }
+
+        // Load slash commands
+        for(SlashCommand command : slashCommands)
+        {
+            addSlashCommand(command);
+        }
     }
 
     @Override
@@ -292,6 +307,35 @@ public class CommandClientImpl implements CommandClient, EventListener
         commands.add(index,command);
     }
 
+    @Override
+    public void addSlashCommand(SlashCommand command)
+    {
+        addSlashCommand(command, slashCommands.size());
+    }
+
+    @Override
+    public void addSlashCommand(SlashCommand command, int index)
+    {
+        if(index>slashCommands.size() || index<0)
+            throw new ArrayIndexOutOfBoundsException("Index specified is invalid: ["+index+"/"+slashCommands.size()+"]");
+        synchronized(slashCommandIndex)
+        {
+            String name = command.getName().toLowerCase();
+            //check for collision
+            if(slashCommandIndex.containsKey(name))
+                throw new IllegalArgumentException("Command added has a name that has already been indexed: \""+name+"\"!");
+            //shift if not append
+            if(index<slashCommands.size())
+            {
+                slashCommandIndex.entrySet().stream().filter(entry -> entry.getValue()>=index).collect(Collectors.toList())
+                    .forEach(entry -> slashCommandIndex.put(entry.getKey(), entry.getValue()+1));
+            }
+            //add
+            slashCommandIndex.put(name, index);
+        }
+        slashCommands.add(index,command);
+    }
+
     @Override
     public void removeCommand(String name)
     {
@@ -461,6 +505,9 @@ public class CommandClientImpl implements CommandClient, EventListener
         if(event instanceof MessageReceivedEvent)
             onMessageReceived((MessageReceivedEvent)event);
 
+        else if(event instanceof SlashCommandEvent)
+            onSlashCommand((SlashCommandEvent)event);
+
         else if(event instanceof GuildMessageDeleteEvent && usesLinkedDeletion())
             onMessageDelete((GuildMessageDeleteEvent) event);
 
@@ -498,6 +545,23 @@ public class CommandClientImpl implements CommandClient, EventListener
         if(manager != null)
             manager.init();
 
+        // Upsert slash commands
+        for (SlashCommand command : slashCommands)
+        {
+            CommandData data = new CommandData(command.getName(), command.getHelp());
+            if (!command.getOptions().isEmpty()) {
+                for (OptionData optionData : command.getOptions()) {
+                    data.addOption(optionData);
+                }
+            }
+
+            if (command.isGuildOnly() && command.getGuildId() != null) {
+                event.getJDA().getGuildById(command.getGuildId()).upsertCommand(data).queue(command1 -> slashCommandIds.add(command1.getId()));
+            } else {
+                event.getJDA().upsertCommand(data).queue(command1 -> slashCommandIds.add(command1.getId()));
+            }
+        }
+
         sendStats(event.getJDA());
     }
 
@@ -607,6 +671,29 @@ public class CommandClientImpl implements CommandClient, EventListener
             listener.onNonCommandMessage(event);
     }
 
+    private void onSlashCommand(SlashCommandEvent event)
+    {
+        final SlashCommand command; // this will be null if it's not a command
+        synchronized(slashCommandIndex)
+        {
+            int i = slashCommandIndex.getOrDefault(event.getName().toLowerCase(), -1);
+            command = i != -1? slashCommands.get(i) : null;
+        }
+
+        if(command != null)
+        {
+            //if(listener != null)
+            //    listener.onCommand(cevent, command);
+            uses.put(command.getName(), uses.getOrDefault(command.getName(), 0) + 1);
+            command.run(event, this);
+            return; // Command is done
+        }
+
+
+        //if(listener != null)
+        //    listener.onNonCommandMessage(event);
+    }
+
     private void sendStats(JDA jda)
     {
         OkHttpClient client = jda.getHttpClient();
-- 
2.30.1

